(function() {
  let l, t = {
    theme: "chrome",
    fontSize: 14,
    // in px
    wrap: !0,
    icon: void 0,
    // auto set during config
    iconName: "sourcecode",
    autocomplete: !1,
    language: "html",
    renderer: null,
    parser: null,
    shortcut: !0,
    aceCss: null,
    fontFamily: null
  };
  const g = (e) => {
    const a = e.getParam("supercode_theme");
    a && typeof a == "string" && (t.theme = a);
    const s = e.getParam("supercode_font_size");
    typeof s == "number" && s > 0 && (t.fontSize = parseInt(s));
    const r = e.getParam("supercode_wrap");
    typeof r == "boolean" && (t.wrap = r);
    const i = e.getParam("supercode_autocomplete");
    typeof i == "boolean" && (t.autocomplete = i);
    const u = e.getParam("supercode_icon");
    if (u && typeof u == "string" && (t.iconName = u), t.icon = e.ui.registry.getAll().icons[t.iconName], !t.icon)
      throw new Error("Supercode Icon name is invalid");
    const o = e.getParam("supercode_parser");
    typeof o == "function" && (t.parser = o);
    const d = e.getParam("supercode_renderer");
    typeof d == "function" && (t.renderer = d);
    const p = e.getParam("supercode_lang");
    p && typeof p == "string" && (t.language = p);
    const f = e.getParam("supercode_shortcut");
    typeof f == "boolean" && (t.shortcut = f);
    const n = e.getParam("supercode_css");
    typeof n == "string" && (t.aceCss = n);
    const c = e.getParam("supercode_font_family");
    c && typeof c == "string" && (t.fontFamily = c);
  }, y = () => {
    const e = [
      "https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/ace.js",
      "https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.15.1/beautify-html.min.js"
    ];
    t.autocomplete && e.push("https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/ext-language_tools.min.js"), e.forEach((a) => {
      let s = document.createElement("script");
      s.src = a, s.type = "text/javascript", document.body.appendChild(s);
    });
  }, h = (e) => {
    if (e.attachShadow({ mode: "open" }), t.aceCss) {
      const r = new CSSStyleSheet();
      r.replaceSync(t.aceCss), e.shadowRoot.adoptedStyleSheets.push(r);
    }
    e.shadowRoot.innerHTML = `
        <div class="supercode-editor" style="width: 100%; height: 100%; position: absolute; left:0; top:0"></div>`;
    const a = e.shadowRoot.querySelector(".supercode-editor");
    a.style.width = "100%", a.style.height = "100%", l = ace.edit(a), l.renderer.attachToShadowRoot();
    const s = {};
    t.autocomplete && (s.enableLiveAutocompletion = !0), t.fontFamily && (s.fontFamily = t.fontFamily), l.setOptions(s), l.setTheme(`ace/theme/${t.theme}`), l.setFontSize(t.fontSize), l.setShowPrintMargin(!1);
  }, b = (e, a, s) => {
    const r = a.cloneNode(!0);
    r.style.position = "relative";
    const i = r.querySelector(".tox-menubar");
    i && (i.innerHTML = `
                <b style='font-size: 14px; font-weight: bold; padding: 9px;'>Source Code Editor</b>
            `);
    let u = !0;
    if (r.querySelectorAll(".tox-tbtn, .tox-split-button").forEach((o) => {
      if (o.getAttribute("data-mce-name") != "supercode") {
        if (o.getAttribute("data-mce-name") === "overflow-button") {
          o.style.display = "none", o.removeAttribute("data-mce-name");
          return;
        }
        o.classList.remove("tox-tbtn--enabled"), o.classList.add("tox-tbtn--disabled"), o.removeAttribute("data-mce-name");
      } else
        u = !1, o.setAttribute("data-mce-name", "supercode-toggle"), o.classList.add("tox-tbtn--enabled"), o.onclick = s;
    }), u) {
      const o = document.createElement("div");
      o.classList = "tox-toolbar__group", o.style.position = "absolute", o.style.right = 0, o.style.height = "100%";
      const d = document.createElement("button");
      d.classList = "tox-tbtn tox-tbtn--enabled", d.innerHTML = `<span class="tox-icon tox-tbtn__icon-wrap">${t.icon}</span>`, d.onclick = s, o.append(d), r.append(o);
    }
    e.append(r);
  }, S = (e, a) => {
    e.style.width = a + "px", e.style.height = "100%", e.style.position = "relative", h(e);
  }, w = (e) => e.getParam("inline") !== !0, x = function(e) {
    if (!w(e))
      return console.error("Supercode Plugin is not supported in inline mode"), !1;
    let a = 0, s, r = !0, i;
    g(e), y();
    const u = () => {
      e.focus(), e.undoManager.transact(function() {
        let n = l.getValue();
        t.renderer && (n = t.renderer(n)), e.setContent(n);
      }), e.selection.setCursorLocation(), e.nodeChanged(), e.execCommand("ToggleView", !1, "supercode");
    }, o = (n) => {
      (n.key === " " && n.ctrlKey || n.key === "Escape") && u();
    }, d = (n) => t.parser ? t.parser(n) : html_beautify(n), p = {
      onShow: (n) => {
        const c = n.getContainer();
        c.style.padding = 0, c.style.display = "flex", c.style.flexDirection = "column", (r || c.childElementCount === 0) && (c.innerHTML = '<div class="supercode-header"></div><div class="supercode-body no-tox-style" id="no-tox-style"></div>', t.shortcut && c.addEventListener("keydown", o), b(c.querySelector(".supercode-header"), s, u), S(c.querySelector(".supercode-body "), a));
        let m = d(e.getContent());
        i || (i = ace.createEditSession(m, `ace/mode/${t.language}`), i.setUseWrapMode(t.wrap), l.setSession(i)), i.setValue(m), l.gotoLine(1 / 0), l.focus();
      },
      onHide: () => {
        t.shortcut && removeEventListener("keydown", o);
      }
    }, f = function() {
      const n = e.getContainer();
      r = a != n.clientWidth, a = n.clientWidth, (r || !s) && (s = n.querySelector(".tox-editor-header")), e.execCommand("ToggleView", !1, "supercode");
    };
    return e.ui.registry.addView("supercode", p), e.ui.registry.addButton("supercode", {
      icon: t.iconName,
      tooltip: "Source Code Editor (Ctrl + space)",
      onAction: f
    }), t.shortcut && e.shortcuts.add("ctrl+32", "Toggles Source Code Editing Mode", f), {
      getMetadata: function() {
        return {
          name: "Source Code Editor",
          url: ""
        };
      }
    };
  };
  tinymce.PluginManager.add("supercode", x);
})();
